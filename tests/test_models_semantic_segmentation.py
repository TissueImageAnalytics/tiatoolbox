import pathlib
import shutil
import sys

import numpy as np

import torch
import torch.nn as nn
import torch.nn.functional as F

sys.path.append('.')
from tiatoolbox.models.segmentation import (IOStateSegmentor,
                                            SemanticSegmentor,
                                            SerializeWSIReader)
from tiatoolbox.wsicore.wsireader import (VirtualWSIReader, WSIMeta,
                                          get_wsireader)


ON_GPU = True
# ----------------------------------------------------


class _CNNTo1(nn.Module):
    """Contain a convolution.

    Simple model to test functionality, this contains a single
    convolution layer which has weight=0 and bias=1.
    """
    def __init__(self):
        super(_CNNTo1, self).__init__()
        self.conv = nn.Conv2d(3, 1, 3, padding=1)
        self.conv.weight.data.fill_(0)
        self.conv.bias.data.fill_(1)

    def forward(self, img):
        output = self.conv(img)
        return output

    @staticmethod
    def infer_batch(model, batch_data, on_gpu):
        """Run inference on an input batch. Contains logic for
        forward operation as well as i/o aggregation.

        Args:
            model (nn.Module): PyTorch defined model.
            batch_data (ndarray): A batch of data generated by
                torch.utils.data.DataLoader.
            on_gpu (bool): Whether to run inference on a GPU.

        """
        device = 'cuda' if on_gpu else 'cpu'
        ####
        model.eval()  # infer mode

        ####
        img_list = batch_data

        img_list = img_list.to(device).type(torch.float32)
        img_list = img_list.permute(0, 3, 1, 2)  # to NCHW

        with torch.no_grad():  # dont compute gradient
            logit_list = model(img_list)
            logit_list = logit_list.permute(0, 2, 3, 1)  # to NHWC
            prob_list = F.relu(logit_list)

        prob_list = prob_list.cpu().numpy()
        return [prob_list]


def _rm_dir(path):
    """Helper func to remove directory."""
    shutil.rmtree(path, ignore_errors=True)


def test_functional_segmentor(_sample_wsi_dict):
    # SAMPLE_ROOT_DIR = '/home/dang/storage_1/workspace/tiatoolbox/tests/local_samples/model_sample_wsi/'
    # _mini_wsi_svs = pathlib.Path(f'{SAMPLE_ROOT_DIR}/wsi2_4k_x_4k.svs')
    # _mini_wsi_jpg = pathlib.Path(f'{SAMPLE_ROOT_DIR}/wsi2_4k_x_4k.jpg')
    # _mini_wsi_msk = pathlib.Path(f'{SAMPLE_ROOT_DIR}/wsi2_4k_x_4k.mask.png')

    save_dir = 'output_model_semantic/'
    # convert to pathlib Path to prevent wsireader complaint
    _mini_wsi_svs = pathlib.Path(_sample_wsi_dict['wsi2_4k_4k_svs'])
    _mini_wsi_jpg = pathlib.Path(_sample_wsi_dict['wsi2_4k_4k_jpg'])
    _mini_wsi_msk = pathlib.Path(_sample_wsi_dict['wsi2_4k_4k_msk'])

    model = _CNNTo1()
    runner = SemanticSegmentor(
                batch_size=8,
                model=model)

    # * test basic running and merging prediction
    # * should dumping all 1 in the output
    iostate = IOStateSegmentor(
        input_resolutions=[{'units' : 'baseline', 'resolution' : 2.0}],
        output_resolutions=[{'units' : 'baseline', 'resolution' : 2.0}],
        patch_input_shape=[1024, 1024],
        patch_output_shape=[512, 512],
        stride_shape=[256, 256],
    )

    _rm_dir(save_dir)
    file_list = [
        _mini_wsi_jpg,
        _mini_wsi_jpg,
    ]
    output_list = runner.predict(
            file_list,
            mode='tile',
            on_gpu=ON_GPU,
            iostate=iostate,
            crash_on_exception=True,
            save_dir=f'{save_dir}/raw/')
    pred_1 = np.load(output_list[0][1] + '.raw.0.npy')
    pred_2 = np.load(output_list[1][1] + '.raw.0.npy')
    assert len(output_list) == 2
    assert np.sum(pred_1 - pred_2) == 0
    # due to overlapping merge and division, will not be
    # exactly 1, but should approximate so
    assert np.sum((pred_1 - 1) > 1.0e-6) == 0
    _rm_dir(save_dir)

    # * test running with mask and svs
    # * also test mergin prediction at designated resolution
    iostate = IOStateSegmentor(
        input_resolutions=[{'units' : 'baseline', 'resolution' : 1.0}],
        output_resolutions=[{'units' : 'baseline', 'resolution' : 1.0}],
        save_resolution={'units' : 'baseline', 'resolution' : 0.25},
        patch_input_shape=[1024, 1024],
        patch_output_shape=[512, 512],
        stride_shape=[256, 256],
    )
    _rm_dir(save_dir)
    output_list = runner.predict(
            [_mini_wsi_svs],
            mask_list=[_mini_wsi_msk],
            mode='wsi',
            on_gpu=ON_GPU,
            iostate=iostate,
            crash_on_exception=True,
            save_dir=f'{save_dir}/raw/')
    reader = get_wsireader(_mini_wsi_svs)
    expected_shape = reader.slide_dimensions(**iostate.save_resolution)
    expected_shape = np.array(expected_shape)[::-1]  # to YX
    pred_1 = np.load(output_list[0][1] + '.raw.0.npy')
    saved_shape = np.array(pred_1.shape[:2])
    assert np.sum(expected_shape - saved_shape) == 0
    assert np.sum((pred_1 - 1) > 1.0e-6) == 0
    _rm_dir(save_dir)
